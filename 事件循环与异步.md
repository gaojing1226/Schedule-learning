> * 原文地址：[https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with.md](https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with.md)

### 一、事件循环
#### 1.什么是事件循环

事件循环有一个简单的任务 —— 去监控调用栈和回调队列。如果调用栈是空的，它就会取出队列中的第一个事件，然后将它压入到调用栈中，然后运行它。  
这样的迭代在事件循环中被称作一个 tick。每一个事件就是一个回调函数。
   
如下代码:
```js
console.log('Hi');
setTimeout(function cb1() { 
    console.log('cb1');
}, 5000);
console.log('Bye');
```
1. console.log('Hi') 进入调用栈，执行，打印Hi,console.log('Hi')  被移出调用栈。
#### 2.setTimeout(…) 是如何工作的

需要重点注意的是 setTimeout(…) 不会自动的把你的回调放到事件循环队列中。它设置了一个定时器。当定时器过期了，宿主环境会将你的回调放到事件循环队列中，以便在以后的循环中取走执行它。

看看下面的代码：
```setTimeout(myCallback, 1000);```  

这并不意味着 myCallback 将会在 1,000ms 之后执行，而是，在 1,000ms 之后将被添加到事件队列。然而，这个队列中可能会拥有一些早一点添加进来的事件 —— 你的回调将会等待被执行。

以第二个参数是 0 的方式调用 setTimeout 就是推迟到调用栈为空才执行回调。
 
来看看下面的代码：

```js
console.log('Hi');
setTimeout(function() {
    console.log('callback');
}, 0);
console.log('Bye');
```
尽管等待的事件设置成 0 了，但是浏览器 console 的结果将会是下面这样：

```js
Hi
Bye
callback
```
 
### 二、 async/await
使用 async 函数声明来定义一个异步函数,一个 async 函数可以包含一个 await 表达式。await 表达式会暂停执行async这个函数，然后等待传给它的 Promise 完成，然后恢复 async 函数的执行，并返回已成功的值。
async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值
